---
title: "dplyr join"
output:
  html_document:
    df_print: paged
---

### База girls & boys

```{r}
library(readr)
library(dplyr)

(boys <- read_delim("csv/boys.txt",delim='|'))
```

```{r}
(girls <- read_delim("csv/girls.txt",delim = "|"))
```


```{r}
(girls2 <- read_delim("csv/girls.txt",delim = "|",locale=locale(decimal_mark = ",")))
```

 ```
# Соединение таблиц (операция join)

Операция join  -- это одна из фундаментальных операций современных баз данных. Соединяя при пгомощи этой оперрации таблицы, мы получаем в качестве результата операции join таблицу в которой часть столбцов взята из первой таблицы, а часть стобцов из второй таблицы  
Строки результата образуют не комбинации произвольных строк левой и правой таблицы, а только строк соответствующих друг другу. Как определяется это соответствие? Обычно накладывается условие равенства друг другу значений некоторых полей в соединяемых таблицах.


## Внутреннее соединение таблиц

Например, бабушки у подъезда хотят рассмотреть в первую очередь те потенциальные пары, которые объединяют общие интересы ( boys.hobby == girls.hobby) 
Для этого подходит операция **inner_join**(*левая_таблица*, *правая_таблица*, by = *условие_соединения*)
```{r}
inner_join(girls, boys,by="hobby")

```
Вы видите в результате несколько раз посторяются строки из таблицы девочки и таблицы мальчики, у которых хобби позволяет им быть участниками нескольких потенциальных пар.
С другой стороны, мальчик Гаврила и девочка Зина имеют более редкие увлечения и они совсем не упомянуты в результате, потому что операция **inner_join** исключает строки, которым нет соответсвия в другой табице из результата.

Результат соединения можно использовать далее как обычную таблицу (data frame) и применять к ним обычные операции **filter()**, **arrange()**,**select()**, **summarise()** и т.п.

* * *


Случай разных имен ключевого столбца в соединяемых таблицах


* * *

```{r}

(girls2 <- rename(girls,hobby_g=hobby))

inner_join(girls2, boys,by=c("hobby_g"="hobby"))

```

Например бабушки захотели посмотреть пары, где возраст не отличается более чем на 15 лет и результат для них нужно упорядочить по имени девочки (): 

```{r}
inner_join(girls, boys, by="hobby",suffix=c("_g","_b")) %>%
  filter((age_b-age_g<15))  %>%
   arrange(name_g) %>% 
   select(-starts_with("row"))
```




## Внешние соединения таблиц
Иногда требуется включать строки из одной из таблиц в результат, даже если им нет соответсвия в другой таблице. 
Тогда используютс операции **left_join()**, **right_join()** и **full_join()**. Такие соединения назвают внешними 

Если мы хотим левую таблицу сделать более приоритетной, то есть включать ее строки в результат, даже если для них нет соответствия в правой таблице, то мы используем операцию **left_join()**
```{r}

left_join(girls, boys,by="hobby") 

```
Зина появилась в списке, а дефицит мальчиков с таким же хобби вышивание был "восполнен" "пустым мальчиком" то есть в этой строке все поля из таблицы boys заполненны пустыми значениями NA


В правом внешнем соединении появляется Гаврила на мотоцикле  с "пустой девочкой". 
```{r}

right_join(girls, boys,by="hobby")

```

В полном внешнем соединении есть и Гаврила на мотоцикле  с "пустой девочкой" и вышивающая Зина с "пустым мальчиком". 
```{r}
 full_join(girls, boys,by="hobby") 
```

# Соединения для отбора строк 

Операции **semi_join()** и **anti_join()** в результат помешают строки только первой таблицы, а вторую таблицу используют для отбора строк первой.

Операция semi_join() выдаёт строки левой таблицы, для которых есть соответствующие строки в правой.
```{r}

semi_join(girls, boys,by="hobby") 

```
А операция anti_join() -- наоборот, выдаёт строки левой таблицы, для которых нет соответствующих строк в правой.
```{r}
anti_join(girls, boys,by="hobby") 
```

